#!/usr/bin/env python
# Copyright 2016 VMWare, Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

'''
VCS is  command line interface for VSphere Container Service

Derived from vmdkops_admin.py

'''

# This file contains 3 parts:
#   Section 1. Generic support for defining command line arguments
#   Section 2. Generic support for printing tables
#   Section 3. Arguments definition and code for VCS CLI
#
# In order to change VCS specific part, go directly to Section 3.


import os
import os.path
import argparse
import sys
import json
import subprocess # needed for CliTable to get screen width info
import six
# Note: We assume 'requests' module is pre-installed (generally true).
# If not, 'pip install requests' is a prerequisite.
import requests


# Section 1 - generic support for defining command line arguments
# ================================================================


def commands():
    """
    This function returns a dictionary representation of a CLI specification that is used to
    generate a CLI parser. The dictionary is recursively walked in the `add_subparser()` function
    and appropriate calls are made to the `argparse` module to create a CLI parser that fits the
    specification.

    Each key in the top level of the dictionary is a command string. Each command may contain the
    following keys:

    * func - The callback function to be called when the command is issued. This key is always
             present unless there are subcommands, denoted by a 'cmds' key.

    * help - The help string that is printed when the `-h` or `--help` paramters are given without
             reference to a given command. (i.e. `vcs-admin -h`). All top level help
             strings are printed in this instance.

    * args - A dictionary of any positional or optional arguments allowed for the given command. The
             args dictionary may contain the following keys:

             * help - The help for a given option which is displayed when the `-h` flag is given
                      with mention to a given command. (i.e. `vcs-admin ls -h`). Help for
                      all options are shown for the command.

             * action - The action to take when the option is given. This is directly passed to
                        argparse. Note that `store_true` just means pass the option to the callback
                        as a boolean `True` value and don't require option parameters.
                        Other options for the action value can be found in the argparse documentation.
                        https://docs.python.org/3/library/argparse.html#action

             * metavar - A way to refer to each expected argument in help documentation. This is
                         directly passed to argparse.
                         See https://docs.python.org/3/library/argparse.html#metavar

             * required - Whether or not the argument is required. This is directly passed to
                          argparse.

             * type - A type conversion function that takes the option parameter and converts it
                      to a given type before passing it to the func callback. It prints an error and
                      exits if the given argument cannot be converted.
                      See https://docs.python.org/3/library/argparse.html#type

             * choices - A list of choices that can be provided for the given option. This list is
                         not directly passed to argparse. Instead a type conversion function is
                         created that only allows one or more of the choices as a comma separated
                         list to be supplied. An error identical to the one presented when using the
                         'choices' option in argparse is printed if an invalid choice is given. The
                         rationale for not directly using the argparse choices option is that
                         argparse requires space separated arguments of the form: `-l a b c`, rather
                         than the defacto single argument, comma separated form: `-l a,b,c`, common
                         to most unix programs.

    * cmds - A dictionary of subcommands where the key is the next word in the command line string.
             For example, in `vcs-admin tenant create`, `tenant` is the command, and `create` is
             the subcommand. Subcommands can have further subcommands, but currently there is only
             one level of subcommands in this specification. Each subcommand can contain the same
             attributes as top level commands: (func, help, args, cmds). These attributes have
             identical usage to the top-level keys, except they only apply when the subcommand is
             part of the command.

             Note that the last subcommand in a chain is the one where the callback function is
             defined. For example, if `tenant create` has a callback, but if a user runs the program
             like: `.vcs-admin tenant` they will get the following error:
             ```
             usage: vcs-admin cluster [-h] {rm,create,ls,modify} ...
             vcs-admin cluster: error: too few arguments
             ```
    """
    return vcs_commands()


def create_parser():
    """ Create a CLI parser via argparse based on the dictionary returned from commands() """
    parser = argparse.ArgumentParser(description='Manage VCS clusters')
    add_subparser(parser, commands())
    return parser


def add_subparser(parser, cmds_dict):
    """ Recursively add subcommand parsers based on a dictionary of commands """
    subparsers = parser.add_subparsers()
    for cmd, attributes in cmds_dict.items():
        subparser = subparsers.add_parser(cmd, help=attributes['help'])
        if 'func' in attributes:
            subparser.set_defaults(func=attributes['func'])
        if 'args' in attributes:
            for arg, opts in attributes['args'].items():
                opts = build_argparse_opts(opts)
                subparser.add_argument(arg, **opts)
        if 'cmds' in attributes:
            add_subparser(subparser, attributes['cmds'])


def build_argparse_opts(opts):
    if 'choices' in opts:
        opts['type'] = make_list_of_values(opts['choices'])
        help_opts = opts['help']
        opts['help'] = '{0}: Choices = {1}'.format(help_opts, opts['choices'])
        del opts['choices']
    return opts


def parse_args():
    parser = create_parser()
    args = parser.parse_args()
    if args != argparse.Namespace():
        return args
    else:
        parser.print_help()


def comma_seperated_string(string):
    return string.split(',')


def make_list_of_values(allowed):
    """
    Take a list of allowed values for an option and return a function that can be
    used to typecheck a string of given values and ensure they match the allowed
    values.  This is required to support options that take comma separated lists
    such as --type in 'cluster create --type=kubernetes,mesos,swarm'
    """

    def list_of_values(string):
        given = string.split(',')
        for g in given:
            if g not in allowed:
                msg = (
                    'invalid choices: {0} (choices must be a comma separated list of '
                    'only the following words \n {1}. '
                    'No spaces are allowed between choices.)').format(g, repr(allowed).replace(' ', ''))
                raise argparse.ArgumentTypeError(msg)
        return given

    return list_of_values


def output(fmt_string, *args):
    """Trivial wraper for printing stuff on the screen"""
    if args:
        six.print_(fmt_string % args)
    else:
        six.print_(fmt_string)


# Section 2 - Generic support for printing tables
#==============================================================================


# A small class for creating ascii based tables

class CliTable:
    """Generic support for formatting ascii tables. Modified from
    cli_table module to allow single file cmd line. Using static methods only"""

    SPACES = 2

    def __init__(self):
        pass

    @staticmethod
    def create(header, data, print_header=True):
        """Create a printable ascii table as a string and return it
        @param header - a list of strings for naming columns
        @param data - a list of rows (a list of strings) containing data

        Note that the length of each row must equal the length of the header list

        Warning: This function does not attempt to fit any fixed width terminal. It
        only formats the data given into columns and does not do any truncation.
        """
        max_sizes = CliTable.max_column_sizes(header, data)
        # Subtract the number of spaces between columns from the term width
        width = CliTable.term_width() - CliTable.SPACES * (len(header) - 1)
        sizes = CliTable.shrink_to_fit(max_sizes, width)
        header = CliTable.truncate([header], sizes)[0]
        data = CliTable.truncate(data, sizes)
        return CliTable.format_table2string(header, data, sizes, print_header)

    @staticmethod
    def term_width():
        """
        Return the width of the terminal. This function assumes stty exists and is runnable. If that is
        not the case than a width of 80 characters is returned as a guess/default. This should never
        happen as stty exists on ESX, Linux and OSX.
        """
        try:
            # Get the number of rows and columns seperated by a space
            output = subprocess.check_output("stty size".split())
            return int(output.split()[1])
        except subprocess.CalledProcessError:
            return 80

    @staticmethod
    def shrink_to_fit(column_sizes, terminal_width):
        """
        If the total size of all columns exceeds the terminal width, then we need to shrink the
        individual column sizes to fit. In most tables, there are one or two columns that are much
        longer than the other columns. We therefore tailor the shrinking algorithm based on this
        principle. The algorithm is as follows:

        1) Truncate the longest column until either the columns all fit in the terminal width or
           the size of the truncated column is equal to the next longest column.
        2) If the columns fit from truncating we are done.
        3) If the columns do not fit, shrink the now equally sized columns 1 char at a time until the
           width fits or these columns equal size of the next smallest column.
        4) Repeat steps 2 and 3 successively until a fit is found.

        Note that there is the pathological case that the terminal is smaller than a single character
        for all columns. Ignore this for now. The only way to handle it would be to print every column
        on it's own line and truncate them to fit. This may be a useful enhancement to make later.
        """
        total_size = sum(column_sizes)
        if total_size <= terminal_width:
            return column_sizes

        # Put the columns in sorted order (largest to smallest)
        sorted_sizes = sorted(column_sizes, reverse=True)

        # Find the index of each sorted column size in the original list and store it
        # Zero out the value in the original list so that we cover duplicate values, since list.index(val)
        # only finds the first instance.
        indexes = []
        for size in sorted_sizes:
            index = column_sizes.index(size)
            indexes.append(index)
            column_sizes[index] = 0

        # Shrink the sorted columns until they fit the terminal width
        while total_size > terminal_width:
            largest = sorted_sizes[0]
            num_largest_columns = sorted_sizes.count(largest)
            if num_largest_columns != len(sorted_sizes):
                next_largest = sorted_sizes[num_largest_columns]
            else:
                # All columns are the same size, so just shrink each one until
                # they fit
                next_largest = 0

            to_remove = total_size - terminal_width
            gap = largest - next_largest

            if gap * num_largest_columns > to_remove:
                # We can resize in this step and we are done
                to_remove_per_column = int(to_remove / num_largest_columns)
                remainder = to_remove % num_largest_columns
                for i in range(num_largest_columns):
                    sorted_sizes[i] = largest - to_remove_per_column
                for i in range(remainder):
                    sorted_sizes[i] = sorted_sizes[i] - 1
            else:
                # We need to remove the max number of chars until we get to the next largest size then
                # try again
                for i in range(num_largest_columns):
                    sorted_sizes[i] = next_largest

            total_size = sum(sorted_sizes)

        # Put the shrunken column sizes in their proper index locations
        for i in range(len(column_sizes)):
            index = indexes[i]
            column_sizes[index] = sorted_sizes[i]

        return column_sizes

    @staticmethod
    def format_table2string(header, data, sizes, print_header):
        """ Actually create the table as a string """
        if print_header:
            s = CliTable.value_row(header, sizes) + '\n'
            s = s + CliTable.divider_row(sizes) + '\n'
        else:
            s = ""
        for row in data:
            s = s + CliTable.value_row(row, sizes) + '\n'
        return s[:-1]

    @staticmethod
    def value_row(values, sizes):
        """ Create a one line string of left justified values using the column sizes in sizes """
        s = ''
        for i in range(len(values)):
            s = s + values[i].ljust(sizes[i] + CliTable.SPACES)
        return s

    @staticmethod
    def divider_row(sizes):
        """ Create a one line string of '-' characters of given length in each column """
        s = ''
        for i in range(len(sizes)):
            s = s + '-'.ljust(sizes[i], '-') + '  '
        return s

    @staticmethod
    def max_column_sizes(header, data):
        """ Determine the maximum length for each column and return the lengths as a list """
        sizes = [len(h) for h in header]
        for row in data:
            for i in range(len(header)):
                if len(row[i]) > sizes[i]:
                    sizes[i] = len(row[i])
        return sizes

    @staticmethod
    def truncate(data, sizes):
        """
        @param data - A list of a list of values
        @param sizes - A list of max sizes

        Shrink each value in data to it's corresponding max size
        Show truncation by replacing the last 2 characters with `..`
        """
        truncated = []
        for row in data:
            truncated_row = []
            for i in range(len(sizes)):
                size = sizes[i]
                column = row[i]
                if len(column) > size:
                    truncated_row.append(column[:size - 2] + '..')
                else:
                    truncated_row.append(column)
            truncated.append(truncated_row)
        return truncated


# Section 3 - VCS Command line implementation.
# ============================================

# First line to be printed for info
VCS_CLI_INFO = "vSphere Container Service admin command line v0.1"

# paths used in misc. requests
VCS_CLUSTER_PATH = "/vcs/cloudstore/clusters"
VCS_CLUSTER_CREATE = '/vcs/clustermanager/vcs-cluster-create'
VCS_CLUSTER_RESIZE = '/vcs/clustermanager/cluster-resize-tasks'

def vcs_commands():
    '''This function returns command line definition.
    See commands() function docstring for more details'''

    return {
        #
        # cluster {create, update, rm , ls} - manipulates clusters
        #
        'cluster': {
            'help': 'Manages cluster - creates, removed, modifies',
            'cmds': {
                'create': {
                    'func': cluster_create,
                    'help': 'Create a new cluster',
                    'args': {
                        '--name': {
                            'help': 'Name of the cluster',
                            'required': True
                        },
                        '--type': {
                            # this one is not requires as we will use
                            # KUBERNETES by default
                            'help': 'Type of the cluster',
                            'choices': ['KUBERNETES', 'MESOS', 'SWARM']
                        },
                        '--slave_count': {
                            'help': "How many slave (minion) nodes to create. Default 1",
                            'metavar': 'COUNT',
                            'default': 1,
                            'type': int

                        },
                        '--etcd_ips': {
                            'help': 'Static IP to use for `etcd` nodes. '
                                    'For multiple nodes, use comma-separated list',
                            'metavar': 'NETWORK',
                            'required': True
                        },
                        '--master_ip': {
                            'help': 'Static IP to use for `kube master.',
                            'metavar': 'NETWORK',
                            'required': True
                        }
                    }
                },
                'resize': {
                    'func': cluster_resize,
                    'help': 'Resize an existing cluster',
                    'args': {
                        '--uuid': {
                            'help': 'The UUID of the cluster',
                            'required': True
                        },
                        '--slave_count': {
                            'help': "How many slave (minion) nodes to scale to.",
                            'metavar': 'COUNT',
                            'type': int,
                            'required': True
                        }
                    }
                },
                'rm': {
                    'func': cluster_rm,
                    'help': 'Delete a cluster',
                    'args': {
                        '--uuid': {
                            'help': 'UUID of the cluster to be removed',
                            'required': True
                        }
                    }
                },
                'ls': {
                    'func': cluster_ls,
                    'args': {
                        '-c': {
                            'help': 'Display selected columns',
                            'choices': all_ls_headers(),
                            'metavar': 'Col1,Col2,...'
                        },
                        '-q': {
                            'help': 'Do not print headers',
                            'action': 'store_true'
                        }
                    },
                    'help': 'List clusters managed by VCS'
                },
                'lsvm': {
                    'func': cluster_lsvm,
                    'args': {
                        # '-c': {
                        #     'help': 'Display selected columns ',
                        #     'choices': all_ls_headers(),
                        #     'metavar': 'Col1,Col2,...'
                        # },
                        '--uuid': {
                            'help': 'UUID of the cluster for which VMs are listed',
                            'required': True
                        },
                        '-q': {
                            'help': 'Do not print headers',
                            'action': 'store_true'
                        }
                    },
                    'help': 'List VMs in a cluster'
                }
            }
        },
        'info': {
            'func': vcs_info,
            'help': 'Show information about the VCS service'
        }
    }


def init():
    '''entry point'''
    # Make sure VCS_HOST is set, and exit if it's not
    try:
        global VCS_HOST
        VCS_HOST = os.environ['VCS_HOST']
    except:
        six.print_("Missing VCS_HOST, please set it before running 'vcs' tool. "
                   "Example: 'VCS_HOST=10.20.1.11:2121 vcs cluster ls'")
        sys.exit(1)


def cluster_create(args):
    """Creates a new cluster - creates VMs with needed components and configures the cluster"""

    # set defaults
    if not args.type:
        args.type = ["KUBERNETES"]
    cluster_type = args.type[0]

    # for now we do not support other clusters:
    if cluster_type != "KUBERNETES":
        output("For now we only support KUBERNETES - type '%s' is not supported yet",
               cluster_type)
        return

    # create and post the request
    # hardcoded stuff is legacy (from Photon Controller POC)
    # and eventually need to be dropped from the API
    create_spec = {
        "clusterState": "CREATING",
        "clusterName": args.name,
        "clusterType": cluster_type,
        "imageId": "Kubernetes-image.vmdk",
        "projectId": "k8s-project",
        "vmNetworkId": "VM Network",
        "diskFlavorName": "Disk flavor",
        "masterVmFlavorName": "Master flavor",
        "otherVmFlavorName": "Slave Flavor",
        "slaveCount": str(args.slave_count),
        "extendedProperties": {
            "etcd_ips": args.etcd_ips,
            "dns": "10.20.145.1",
            "gateway": "10.20.107.253",
            "netmask": "255.255.252.0",
            "master_ip": args.master_ip,
            "container_network": "10.20.107.253/20"
        }
    }

    url = VCS_HOST + VCS_CLUSTER_CREATE
    resp = requests.post(url, data=json.dumps(create_spec))
    resp.raise_for_status()
    output("Cluster %s creation initiated.", args.name)


def cluster_ls(args):
    """Lists clusters managed by VCS"""

    resp = requests.get(VCS_HOST + VCS_CLUSTER_PATH)
    resp.raise_for_status()
    known_clusters = resp.json()['documentLinks']

    if args.c:
        headers, rows = ls_dash_c(args.c, known_clusters)
    else:
        headers = all_ls_headers()
        rows = generate_ls_rows(known_clusters)

    output(CliTable.create(headers, rows, not args.q))


def all_ls_headers():
    """ Return a list of all header for ls -l """
    return ['Name', 'Type', 'State', 'Health', 'Reason',
            'Slaves', 'ETCD_IP', 'Master_IP', 'UUID']


def generate_ls_rows(known_clusters):
    """ Gather all cluster info into rows that can be used to format a table """
    rows = []
    for cluster in known_clusters:
        resp = requests.get(VCS_HOST + cluster)
        cluster_info = resp.json()
        ext_info = cluster_info['extendedProperties']
        if cluster_info['clusterState'] == "CREATING":
            health = "n/a"
        else:
            health = cluster_info['clusterhealth']
        if 'healthTip' in cluster_info:
            reason = cluster_info['healthTip']
        else:
            reason = "n/a"
        rows.append([
            cluster_info['clusterName'],
            cluster_info['clusterType'],
            cluster_info['clusterState'],
            health,
            reason,
            str(cluster_info['slaveCount']),
            ext_info['etcd_ips'],
            ext_info['master_ip'],
            os.path.basename(cluster_info['documentSelfLink'])
        ])
    return rows


def ls_dash_c(columns, clusters):
    """ Return only the columns requested in the format required for table construction """
    all_headers = all_ls_headers()
    all_rows = generate_ls_rows(clusters)
    indexes = []
    headers = []
    choices = commands()['cluster']['cmds']['ls']['args']['-c']['choices']
    for i in range(len(choices)):
        if choices[i] in columns:
            indexes.append(i)
            headers.append(all_headers[i])
    rows = []
    for row in all_rows:
        rows.append([row[i] for i in indexes])
    return (headers, rows)


def cluster_lsvm(args):
    """Lists VMs running under a specified cluster"""

    cluster_uuid = args.uuid
    resp = requests.get(get_cluster_path_uuid(cluster_uuid) + "/vms")
    resp.raise_for_status()

    headers = ['VM_Name']
    vms = []
    for v in resp.json():
        vms.append([v["vmName"]])
    output(CliTable.create(headers, vms, not args.q))


def get_cluster_path_uuid(cluster_uuid):
    '''constructs URL for cluster manipulation'''
    return VCS_HOST + VCS_CLUSTER_PATH + "/" + cluster_uuid


def cluster_rm(args):
    """Removes a cluster managed by VCS. That includes VM deletion"""
    cluster_uuid = args.uuid
    url = get_cluster_path_uuid(cluster_uuid)
    resp = requests.delete(url)
    resp.raise_for_status()
    output("Cluster %s deleted", cluster_uuid)


def cluster_resize(args):
    """Re-configures a cluster based on the new config passed in args"""
    cluster_uuid = args.uuid
    url = VCS_HOST + VCS_CLUSTER_RESIZE
    data = {"clusterId": args.uuid, "newSlaveCount": args.slave_count}
    resp = requests.post(url, json.dumps(data))
    resp.raise_for_status()
    output("Submitted request to resize cluster '%s' to %d slaves. ",
           cluster_uuid, args.slave_count)


def vcs_info(args):
    """Reports overall status of VCS service"""
    output(VCS_CLI_INFO)
    resp = requests.get(VCS_HOST)
    resp.raise_for_status()
    if VCS_CLUSTER_PATH not in resp.json()['documentLinks']:
        output("VCS seems down - it's missing from services list on %s", VCS_HOST)
    else:
        output("VCS is certainly up, and hopefully healthy on %s", VCS_HOST)


if __name__ == '__main__':
    init()
    cmd_args = parse_args()
    if cmd_args:
        try:
            cmd_args.func(cmd_args)
        # TBD: better error handling. Can do in command to provide 
        # individualized info, or here by looking at different Exception
        # types
        except Exception as ex:
            output("VCS request failed. Reason: %s", ex)
